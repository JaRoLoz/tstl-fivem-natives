import fs from "node:fs/promises";
import fetch from "node-fetch";

const response = await fetch("https://www.npmjs.com/package/@citizenfx/client/file/2f83c0b9a6706e83a1b996af781fb93c14b26fac2491a91325796520377c834a");
const text = await response.text();

const reservedKeyWords = ["repeat", "end"];
const transformType = (type) => {
    const replacements = {
        "number[]": "Vector3",
        "number": "number",
        "string": "string",
        "boolean": "boolean",
        "bool": "boolean",
        "any": "any",
        "object": "object",
        "void": "void",
    }
    for (const [key, value] of Object.entries(replacements))
        if (type.toLowerCase().includes(key))
            return value;
    return "any";
}


const getFunctionName = (line) => {
    const splitted = line.split("(");
    return splitted[0];
}

const getFunctionReturnType = (line) => {
    const splitted = line.split(":");
    const retval = splitted[splitted.length - 1].trim();
    const returnType = retval.startsWith('[')
        ? retval.replace("[", "").replace("]", "").trim().split(",")
        : retval;
    return returnType;
}
const returnTypeToString = (types) => {
    if (Array.isArray(types))
        return `LuaMultiReturn<[${types.map(type => transformType(type)).join(", ")}]>`;
    return transformType(types);
}

const checkForReservedKeyWords = (name) => {
    if (reservedKeyWords.includes(name))
        return "_" + name;
    return name;
}

const getFunctionParameters = (line) => {
    const splitted = line.split("(");
    const parameters = splitted[1].split(")")[0].split(",");
    if (parameters.length === 1 && parameters[0].trim() === "")
        return [];
    const paramStrings = parameters.map(param => param.trim());
    const paramsArray = paramStrings.map(param =>
        param.trim().split(":"));
    return paramsArray.map(([name, type]) => [checkForReservedKeyWords(name).replace("?", ""), type]);
}

const splitted = text.split("declare function");
const functions = splitted.map(line => line.split(";")[0].trim()).filter(line => !line.startsWith("/*"));
const functionStrings = new Map();
functions.forEach(line => {
    const params = getFunctionParameters(line)
        .map(([name, type]) => [name, transformType(type)]);
    const name = getFunctionName(line);
    const retval = getFunctionReturnType(line);
    const returnType = returnTypeToString(retval);
    functionStrings.set(name, `declare function ${name}(${params.map(([name, type]) => `${name}: ${type}`).join(", ")}): ${returnType};`);
});

const template = `/* Generated by https://github.com/JaRoLoz/tstl-fivem-natives */
declare global {
    const source: number;
}
type Vector2 = {
    x: number,
    y: number
};
declare function vector2(x: number, y: number): Vector2;
type Vector3 = {
    x: number,
    y: number,
    z: number
};
declare function vector3(x: number, y: number, z: number): Vector3;
type Vector4 = {
    x: number,
    y: number,
    z: number,
    w: number   
};
declare function vector4(x: number, y: number, z: number, w: number): Vector4;
declare function CreateThread(callback: () => void): void;
declare function AddEventHandler(eventName: string, cb: (...args: any[]) => void): void;
declare function RegisterNetEvent(eventName: string, cb: (...args: any[]) => void): void;
declare function TriggerClientEvent(eventName: string, ...args: any[]): void;
declare function TriggerServerEvent(eventName: string, ...args: any[]): void;
declare function TriggerEvent(eventName: string, ...args: any[]): void;
declare function SendNUIMessage(data: object): void;
${Array.from(functionStrings.values()).join("\n")}
`;

try {
    await fs.writeFile('native_defs.d.ts', template);
    console.log("File written successfully");
} catch (err) {
    console.error("Error writing file", err);
}

function a() {
    return 4, 4;
}
